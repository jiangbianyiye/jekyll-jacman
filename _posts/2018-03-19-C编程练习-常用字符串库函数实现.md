---
layout: post

title: C编程练习-常用字符串库函数实现

categories: C

tags: C exercise

---

C语言常用字符串处理函数及其模拟实现

### string.h库函数实现

#### strlen

- 功能：求字符串长度（不包括'\0'）
- 函数声明：size_t strlen (const char*);

实现：

```c
size_t  mystrlen(char const* _Str) {
    //库函数实现不检查空指针
    if (_Str == NULL) {
		return 0;
	}
	int len = 0;
	while (*_Str++ != '\0') {
		len++;
	}
	return len;
}
```

#### strcpy

- 功  能: 字符串拷贝
- 函数声明：char*  strcpy( char* _Dest, char const* _Source);

实现：

```c
char*  mystrcpy(char* _Dest, char const* _Source) {
    //库函数实现不检查空指针
	if (_Source == NULL || _Dest == NULL) {
		return NULL;
	}
	const char* src = _Source;
	char* dest = _Dest;
	while (*src != '\0') {
		*dest++ = *src++;
	}
	*dest = *src;
	return _Dest;
}
```

#### strcat

- 功  能: 拼接字符串
- 函数声明：char* strcat(char* _Destination, const char*, _Source);

实现：

```c
char* mystrcat(char* _Destination, const char* _Source)
{
	if (_Destination == NULL || _Source == NULL) {
		return NULL;
	}
	char* p = _Destination;
	while (*p++ != '\0');
	p--;
	while (*_Source != '\0') {
		*p++ = *_Source++;
	}
	return _Destination;
}
```



#### strcmp

- 功  能: 比较字符串
- 函数声明：int  strcmp(char const* _Str1, char const* _Str2);

实现：

```c
int  mystrcmp(char const* _Str1, char const* _Str2)
{
    //库函数实现不检查空指针
	if (_Str1 == NULL || _Str2 == NULL) {
		return 0;
	 }
	int cmp = 0; //默认相等
	while (*_Str1 == *_Str2 && *_Str1 != '\0' && *_Str2 != '\0') {
		_Str1++;
		_Str2++;
	}
	if (*_Str1 < *_Str2) {
		cmp = -1;
	}
	else if (*_Str1 > *_Str2) {
		cmp = 1;
	}
	return cmp;
}
```

#### _strcmpi

- 功  能: 比较字符串,忽略大小写
- 函数声明：int  strcmpi(char const* _Str1, char const* _Str2);

实现：

```c
//VC2014库函数实现是统一转换为小写字母
char toUpper(char ch) {
	if (ch <= 'z'&&ch >= 'a') {
		ch += 'A' - 'a';
	}
}
int  mystrcmpi(char const* _Str1, char const* _Str2) {
    //库函数实现不检查空指针
	if (_Str1 == NULL || _Str2 == NULL) {
		return 0;
	}
	for (char ch1 = toUpper(*_Str1), ch2 = toUpper(*_Str2); 
	ch1 == ch2 && ch1 != '\0';) {
		ch1 = toUpper(*(++_Str1));
		ch2 = toUpper(*(++_Str2));
	}
	if (*_Str1 == '\0'&& *_Str2 == '\0') {
		return 0;
	}
	else {
		char ch1 = toUpper(*_Str1), ch2 = toUpper(*_Str2);
        //VC2014库函数返回差值，gcc返回+1，-1
		return 	ch1 - ch2;
	}
}
```

#### strncmp

- 功  能: 比较字符串，最大比较n位
- 函数声明：int strncmp(char const* _Str1, char const* _Str2,size_t  _MaxCount);

实现：

```c
int mystrncmp(char const* _Str1, char const* _Str2,size_t  _MaxCount) {
	if (_Str1 == NULL || _Str2 == NULL) {
		return 0;
	}
	while (*_Str1 == *_Str2 && *_Str1 != '\0' && _MaxCount-- > 0) {
		_Str1++;
		_Str2++;
	}
	if (*_Str1 ==  *_Str2) {
		return 0;
	}
	else if(*_Str1 > *_Str2){
		return 	1;
	}
	else {
		return -1;
	}
}
```



#### _strnicmp

- 功  能: 比较字符串，最大比较n位,忽略大小写
- 函数声明：int _strnicmp(char const* _String1,char const* _String2, size_t _MaxCount);

实现：

```c
int mystrnicmp(char const* _Str1, char const* _Str2,size_t _MaxCount) {
	if (_Str1 == NULL || _Str2 == NULL) {
		return 0;
	}
	for (char ch1 = toUpper(*_Str1), ch2 = toUpper(*_Str2);
		ch1 == ch2 && ch1 != '\0' && _MaxCount-- > 0; ) {
		ch1 = toUpper(*(++_Str1));
		ch2 = toUpper(*(++_Str2));
		
	}
	if (*_Str1 == *_Str2) {
		return 0;
	}
	else {
		char ch1 = toUpper(*_Str1), ch2 = toUpper(*_Str2);
		if (ch1 < ch2) {
			return -1;
		}
		else {
			return 1;
		}
	}
}
```

#### _strrev

- 功  能: 翻转字符串
- 函数声明：char* _strrev(char* _String);

实现：

```c
char* mystrrev(char* _String) {
    //库函数实现不检查空指针
	if (_String == NULL) {
		return NULL;
	}
	int len = 0;
	for (char* p = _String; *p != '\0'; p++) {
		len++;
	}
	for (int i = 0; i < len / 2; i++) {
		char ch = _String[i];
		_String[i] = _String[len - 1 - i];
		_String[len - 1 - i] = ch;
	}
	return _String;
}
```

#### strstr

- 功  能: 在母串中查找指定字符串的第一次出现的位置
- 函数声明：char* strstr(const char*  _String, const char *_SubString);

实现：

```c
char* mystrstr(const char*  _String, const char *_SubString)
{
	//库函数实现不检查空指针
	if (_String == NULL || _SubString == NULL) {
		return NULL;
	}
	const char * p = NULL;
	const char* mstr = _String;
	while (*mstr != '\0') {
		int flag = 1;//假设存在字串
		const char *mp = mstr, *subp = _SubString;
		//只需考虑母串到结尾
		//因为若待查找到的字串到结尾，则查到一个匹配的串
		//此时只有字串和母串都到'\0'关系式子*mp==*sub才成立
		while (*mp == *subp && *mp != '\0') {
			//!!此处*mp != '\0';少写了mp左侧的*,调了半个多小时
			//printf("%5c", *subp);
			subp++;
			mp++;
		}
		//printf("subp:[%s]\n", subp);
		if (*subp == '\0') { //找到
							 //printf("%c", *subp);
			p = mstr;
			break;
		}
		else if (*mp == '\0') {	//母串比较到结尾还没找到
			break;
		}
		mstr++;
	}
	return (char *)p;
}
```

#### _strupr

- 功  能: 将字符串中的小写字母转换为大写字母
- 函数声明：char  _strupr(char* _String);

实现：

```c
char*  mystrupr(char* _String) {
    //库函数实现不检查空指针
	if (_String == NULL) {
		return NULL;
	}
	char * pstr = _String;
	while (*pstr != '\0') {
		if (*pstr <= 'z'&& *pstr >= 'a') {
			*pstr = *pstr + 'A' - 'a';
		}
		pstr++;
	}
	return _String;
}
```

#### _strlwr

- 功  能: 将字符串中的大写字母转换为小写字母
- 函数声明：char  _strlwr(char* _String);

实现：

```c
char*  mystrlwr(char* _String) {
    //库函数实现不检查空指针
	if (_String == NULL) {
		return NULL;
	}
	char * pstr = _String;
	while (*pstr != '\0') {
		if (*pstr <= 'Z'&& *pstr >= 'A') {
			*pstr = *pstr + 'a' - 'A';
		}
		pstr++;
	}
	return _String;
}
```

#### _strset

- 功  能: 将一个串中的所有字符都设为指定字符
- 函数声明：char* _strset(char* _Destination, int _Value)

实现：

```c
char* mystrset(char* _Destination, int _Value) {
    //库函数实现不检查空指针
    if (_Destination == NULL) {
		return NULL;
	}
	char *p = _Destination;
	while (*p != '\0') {
		*p = _Value;
		p++;
	}
	return 	_Destination;
}
```

### 宽字符操作

中文字符及宽字符串需定义为wchar_t ,占两个字节，字面量需在左侧加'L',如 `wchar_t L'枫'`

宽字符输出使用putwchar()；或wprintf(L"%c", ch);

宽字符串的输出用wprintf(L"%ls\n", str);

输出中文需要本地化

```c
#include<locale.h>

setlocale(LC_ALL,"zh-CN");
```

#### 宽字符串对应库函数

- wcslen: 宽字符串长度
- wcscpy:宽字符串拷贝
- .....

### 字符串与数字相互转换

字符串和数字除了可以利用sprintf相互转换外还有如下函数

#### atoi

- 功  能:  把字符串转换成整型数
- 函数声明：int atoi(const char* _String);

实现：

```c
//只考虑正数
int myatoi(const char* _String) {
	//库函数实现不检查空指针
	if (_String == NULL) {
		return 0;
	}
	int num = 0;
	while (*_String<='9'&&*_String>='0') {
		num *= 10;
		num += *_String - '0';
		_String++;
	}
	return num;
}
```

#### _itoa

- 功  能: 将一整数转换为字符串
- 函数声明：char* _itoa(int _Value, char* _Buffer, int _Radix)

实现：

```c
//只考虑正数
char* myitoa(int _Value, char* _Buffer, int _Radix) {
	int len = 0;
	for (int num = _Value; num != 0; num /= _Radix) {
		len++;
	}
	_Buffer[len] = '\0';
	while (_Value != 0) {
		int digit = _Value%_Radix;
		if (digit <= 10) {
			_Buffer[--len] = digit +'0';
		}
		else {
			_Buffer[--len] = digit-10 + 'a';
		}
		_Value /= _Radix;
	}
	return _Buffer;
}
```

#### atof

- 功  能: 将字符串转换为双精度浮点数
- 函数声明：char* _strset(char* _Destination, int _Value)

实现：

```c
double myatof(const char * _String){
    //库函数实现不检查空指针
	if (_String == NULL) {
		return 0.0;
	}
	double num = 0.0;
	int sign = 1;
    //处理符号位
	if (*_String == '+') {
		_String++;
	}
	else if(*_String == '-') {
		sign = -1;
		_String++;
	}
    //处理整数部分
	while (*_String >= '0'&&*_String <= '9') {
		num *= 10;
		num += *_String - '0';
		_String++;
	}
    //处理小数点
	if (*_String == '.') {
		_String++;
	}
    //处理小数部分
	double decimal = 1.0;
	while (*_String >= '0'&&*_String <= '9') {
		decimal *= 0.1;
		num += ((*_String - '0') * decimal);
		_String++;
	}
	return num*sign;
}
```

#### ftoa//库函数中无此函数，自定义

可使用char str[100];sprintf(str,"%f",123.456);完成转换

- 功  能: 将双精度浮点数转换为字符串
- 函数声明：char* ftoa(char * _String,char* _Buffer，int  _Accuracy)；

实现：浮点数由于其内存表示数据不连续的缺陷，无法得到精确值，故需要输入精度，即指名输出小数点后多少位

```c
char* ftoa(double num ,char* _Buffer,int _Accuracy)
{
	char* str = _Buffer;
	//printf("%p\n", _Buffer);
	//处理符号位
	if (num < 0) {
		_Buffer[0] = '-';
		num *= -1;
		_Buffer++;
	}	
	//printf("-:%p\n", _Buffer);
	//处理整数部分
	int int_part = (int)num;
	int len = 0;
	for (; int_part != 0; int_part /= 10) {
		len++;
	}
	int lenbak = len;
	_Buffer[len] = '.';
	int_part = (int)num;
	while (int_part != 0) {
		int digit = int_part%10;
		//printf("digt:%d,len=%d\n", digit,len);
		_Buffer[--len] = digit + '0';
		int_part /= 10;
	}
	//处理小数部分
	_Buffer = _Buffer+lenbak+1;
	//printf("int:%p\n", _Buffer);
	double decimal_part = num - (int)num;
	for (int i = 0; i < _Accuracy; i++) {
		decimal_part *= 10;
		int digit = (int)decimal_part;
		_Buffer[i] = digit + '0';
		decimal_part -= digit;
	}

	return str;
}
```





