---
layout: post
title: 《算法导论》学习笔记
tags: Algorithms
categories: Algorithms
date: 2017-04-01 20:23:00 +0800
---

《算法导论》 第三版的学习笔记。记录自己的疑问和心得。同时所有伪代码都将用C重写。

### Chapter 01
#### 插入排序(2.1)

```c
void insertionSort(int* a,int n){
  for(int j=1;j<n;j++){
    int key=a[j];
    int index=j;
    for(int i=j-1;i>=0;i--){
      if(a[i]>key){
        a[i+1]=a[i];
        index=i;
      }
    }
    a[index]=key;
  }
  return;
}
```

#### 归并排序(2.3)

```c

void mergeSort(int A[],int p,int r){
  if(p<r){
    int q=(p+r)/2;
    mergeSort(A,p,q);
    mergeSort(A,q+1,r);
    merge(A, p, q, r);
  }
}

void merge(int A[],int p,int q, int r){
  int L[q-p+2];
  int R[r-q+1];
  int i=0;
  for(i=0;i<q-p+1;i++){
    L[i]=A[p+i];
  }
  for(i=0;i<r-q;i++){
    R[i]=A[q+i+1];
  }
  L[q-p+1]=R[r-q]=100000;//MAX_INT;
  i=0;
  int j=0;
  for(int k=p;k<=r;k++){
    if(L[i]<R[j]){
      A[k]=L[i];
      i++;
    }
    else{
      A[k]=R[j];
      j++;
    }
  }
}

```

另一归并方法：归并过程不设置哨病，而是一旦数组L或R的所有元素均备复制回A立刻停止，然后把另一个数组的剩余部分复制回A

```c

void mergeWithoutSentinels(int A[],int p,int q,int r){
  int Ln=q-p+1,Rn=r-q;
  int L[Ln];
  int R[Rn];
  int i=0;
  for(i=0;i<q-p+1;i++){
    L[i]=A[p+i];
  }
  for(i=0;i<r-p;i++){
    R[i]=A[q+i+1];
  }
  i=0;
  int j=0;
  for(int k=p;k<=r;k++){
    if(i==Ln){
      A[k]=R[j++];
    }else if(j==Rn){
      A[k]=L[i++];
    }else if(L[i]<R[j]){
      A[k]=L[i++];
    }else{
      A[k]=R[j++];
    }
  }
}

```

#### 选择排序(练习2.2-2)

```c
void selectSort(int* a, int n){
  int min=0;
  for(int i=0;i<n-1;i++){
    min=i;
    for(int j=i+1;j<n;j++){
      if(a[j]<a[min])
        min=j;
    }
    int t=a[i];
    a[i]=a[min];
    a[min]=t;
  }
}

```

#### 线性查找(练习2.1-3)

```c
int linerSearch(int *a, int n, int v){
  for(int i=0;i<n;i++){
    if(a[i]==v)
      return i;
  }
  return -1;
}

```

#### 二分查找(迭代2.3-5)

```c

int binarySearch(int* a,int n,int v){
  int i=0,k=n-1,j;
  while(i<=k){
    j=(i+k)/2;
    if(a[j]==v){
      return j;
    }else if(a[j]>v){
      k=j-1;
    }else{
      i=j+1;
    }
  }
  return -1;
}

```

#### 练习

1.1-4
>How are the shortest-path and traveling-salesman problems given above similar? How are they different?

相同点：最短路径与旅行商问题都要在一张图中找出最短路径；    
不同点：最短路径只需找出两点间的最短路，而旅行商问题需要找出经过多点并返回原点的最短路径。
> 旅行商问题是NP完全的，没有已知的有效算法。

2.1-3
>Consider the searching problem:    
>Input: A sequence of n numbers A=⟨a1,a2,…,an⟩ and a value ν.    
>Output: And index i such that ν=A[i] or the special value NIL if ν does not appear in A    
>Write the pseudocode for linear search, which scans through the sequence, looking for ν. Using a loop invariant, >prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

伪代码：

```
LINEAR-SEARCH(A,v)
	i=NIL
	for j=1 to A.length
		if A[j]=v
			i=j
	return i
```

循环不变式：在每次循环之前，A[1...j-1]包含的元素都与v不同    
初始化：第一次循环之前数组A为空，显然成立。    
保持：每次循环之前A[1...j-1]中不包含v,随后检查A[j]是否与v相等，相等则跳出循环，不等则继续下次循环，此时A[1...j]中不包含v。    
终止：循环终止时有两种情况。①j>A.length，此时A[1..j]不含v;②A[j]=v,此时A[1...j-1]不包含v。

2.1-4

>Consider the problem of adding two n-bit binary integers, stored in two n-element arrays A and B. The sum of the two integers should be stored in binary form in an (n+1)-element array C. State the problem formally and write pseudocode for adding the two integers.

输入：两个以n元数组形式存储的二进制数A,B。    
输出：以n+1元数组形式存储的数组C,C=A+B。    
伪代码：

```
BINARY-SUM(A, B):
  C = new integer[A.length + 1]

  carry = 0
  for i = 1 to A.length
      C[i] = (A[i] + B[i] + carry) % 2  // 求余数
      carry = (A[i] + B[i] + carry) / 2 // 求商
  C[i] = carry

  return C

```

2.3-7

>★ Describe a Θ(nlgn)-time algorithm that, given a set S of n integers and another integer x, determines whether or not there exists two elements of S whose sum is exactly x.

伪代码：

```
PAIR-EXISTS(S, x):
  A = MERGE-SORT(S,1,S.length)

  for i = 1 to S.length
      if BINARY-SEARCH(A, x - S[i]) != NIL
          return true

  return false
```

##### 思考题

