---
layout: post
title: 《算法导论》学习笔记
tags: Algorithms
categories: Algorithms
date: 2017-04-01 20:23:00 +0800
---

《算法导论》 第三版的学习笔记。记录自己的疑问和心得。同时所有伪代码都将用C重写。

### Chapter 01
#### 插入排序(2.1)

```c
void insertionSort(int* a,int n){
  for(int j=1;j<n;j++){
    int key=a[j];
    int index=j;
    for(int i=j-1;i>=0;i--){
      if(a[i]>key){
        a[i+1]=a[i];
        index=i;
      }
    }
    a[index]=key;
  }
  return;
}
```

#### 线性查找(练习2.1-3)

```c
int linerSearch(int *a, int n, int v){
  for(int i=0;i<n;i++){
    if(a[i]==v)
      return i;
  }
  return -1;
}
```

#### 练习

1.1-4
>How are the shortest-path and traveling-salesman problems given above similar? How are they different?

相同点：最短路径与旅行商问题都要在一张图中找出最短路径；    
不同点：最短路径只需找出两点间的最短路，而旅行商问题需要找出经过多点并返回原点的最短路径。
> 旅行商问题是NP完全的，没有已知的有效算法。

2.1-3
>Consider the searching problem:    
>Input: A sequence of n numbers A=⟨a1,a2,…,an⟩ and a value ν.    
>Output: And index i such that ν=A[i] or the special value NIL if ν does not appear in A    
>Write the pseudocode for linear search, which scans through the sequence, looking for ν. Using a loop invariant, >prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

伪代码：

```
LINEAR-SEARCH(A,v)
	i=NIL
	for j=1 to A.length
		if A[j]=v
			i=j
	return i
```

循环不变式：在每次循环之前，A[1...j-1]包含的元素都与v不同    
初始化：第一次循环之前数组A为空，显然成立。    
保持：每次循环之前A[1...j-1]中不包含v,随后检查A[j]是否与v相等，相等则跳出循环，不等则继续下次循环，此时A[1...j]中不包含v。    
终止：循环终止时有两种情况。①j>A.length，此时A[1..j]不含v;②A[j]=v,此时A[1...j-1]不包含v。

2.1-4

>Consider the problem of adding two n-bit binary integers, stored in two n-element arrays A and B. The sum of the two integers should be stored in binary form in an (n+1)-element array C. State the problem formally and write pseudocode for adding the two integers.

输入：两个以n元数组形式存储的二进制数A,B。    
输出：以n+1元数组形式存储的数组C,C=A+B。    
伪代码：

```
BINARY-SUM(A, B):
  C = new integer[A.length + 1]

  carry = 0
  for i = 1 to A.length
      C[i] = (A[i] + B[i] + carry) % 2  // 求余数
      carry = (A[i] + B[i] + carry) / 2 // 求商
  C[i] = carry

  return C

```
##### 思考题

